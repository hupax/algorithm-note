//
// Created by 沙枭 on 2024/4/18.
//
// 1104 天长地久
#include <iostream>
using namespace std;

void findNumbers(int sum, int num, int digit) {
    if (digit == 0) {
        if (sum == 0) {
            cout << num << endl;
        }
        return;
    }

    for (int i = 0; i <= 9; i++) {
        if (sum - i >= 0 && sum - i <= (digit - 1) * 9) {
            findNumbers(sum - i, num * 10 + i, digit - 1);
        }
    }
}

int main() {
    findNumbers(45, 0, 6);
    return 0;
}
/*这个代码使用了递归和回溯的方法来快速找出所有符合条件的6位正整数。让我们逐步分析代码的实现过程：

1. 首先，定义了一个递归函数`findNumbers`，它有三个参数：
   - `sum`：表示当前剩余的数位和。
   - `num`：表示当前已经生成的数。
   - `digit`：表示当前还需要生成的数位数。

2. 在`findNumbers`函数中，首先判断递归的终止条件：
   - 如果`digit`为0，说明已经生成了6位数。
   - 此时，如果`sum`也为0，说明当前生成的数满足数位和为45的条件，将其输出。
   - 然后，函数直接返回，结束当前递归分支。

3. 如果还没有达到递归终止条件，则进入循环，从0到9枚举当前位置可能的数字：
   - 对于每个数字`i`，判断以下条件：
     - `sum - i >= 0`：确保剩余的数位和非负，即当前数字不能超过剩余的数位和。
     - `sum - i <= (digit - 1) * 9`：确保剩余的数位和不超过剩余位数能够达到的最大值，即剩余位数全部填9的情况。
   - 如果满足以上条件，则进行递归调用`findNumbers`：
     - 将`sum`减去当前数字`i`，表示剩余的数位和。
     - 将`num`乘以10加上当前数字`i`，表示将当前数字添加到已经生成的数的末尾。
     - 将`digit`减1，表示剩余需要生成的数位数减少了1。

4. 在主函数`main`中，调用`findNumbers`函数，传入初始条件：
   - `sum`为45，表示目标数位和为45。
   - `num`为0，表示初始时还没有生成任何数位。
   - `digit`为6，表示需要生成6位数。

通过递归和回溯的方法，代码可以高效地生成所有满足条件的6位正整数。具体过程如下：

- 从最高位开始，枚举每一位可能的数字（0到9）。
- 对于每个数字，判断是否满足剩余数位和的条件，如果满足，则递归生成下一位数。
- 当生成了6位数后，判断数位和是否为45，如果是，则输出该数。
- 通过回溯的方式，在生成完一个数后，回到上一层递归，尝试下一个可能的数字。

这种方法避免了暴力枚举所有6位数的情况，通过在生成过程中进行剪枝，只保留有可能满足条件的数，从而大大减少了计算量。

时间复杂度分析：
- 在最坏情况下，代码会生成所有的6位数，时间复杂度为O(10^6)。
- 但是，由于在生成过程中进行了剪枝，实际的计算量会远小于10^6。

空间复杂度分析：
- 递归的最大深度为6，因此空间复杂度为O(6)，即递归调用栈的最大深度为6。

总的来说，这个代码通过递归和回溯*/