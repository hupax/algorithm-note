//
// Created by hupax on 25-3-29.
//
#include <iostream>
#define foi(a, b) for (int i=a; i<=b; i++)
#define foj(a, b) for (int j=a; j<=b; j++)
#define gc getchar_unlocked()
using namespace std;
const int mod=1e9+7;
const int N=5e3+5;
char s[N];
int n=1, dp[N][N]; // dp[i][j] 表示前i个位置,j个左括号未匹配的方案数
int main() {
    s[n]=gc;
    while (s[n]!='\n')s[++n]=gc;
    --n;
    dp[0][0]=1;
    foi(1, n) { // 每个位置
        foj(0, n) { // 前i个位置,j个左括号未匹配
            // 插入左括号
            if (j>=1) dp[i][j]=(dp[i][j] + dp[i-1][j-1])%mod;
            
            if (j+1<=n) dp[i][j+1]=(dp[i][j+1] + dp[i-1][j])%mod;
            
            if (s[i]=='(' && j>=1) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;
            
            if (s[i]==')' && j+1<=n) dp[i][j]=(dp[i][j]+dp[i-1][j+1])%mod;
        }
    }
    cout<<dp[n][0];
    
    return 0;
}
/*
 *
当然可以，我现在就一步步把**代码的完整框架和写法思路**描述给你，不直接给代码，而是让你能**心里有谱**地知道代码为什么要这样写。

---

## ✅ 完整的代码框架结构

---

### 【1】输入 + 预处理部分

- 输入原始括号序列 \( s[1..n] \)
- 遍历一遍 \(s\)，计算最少需要补的左括号 `needLeft` 和右括号 `needRight`

**核心思想**：

- 扫描字符串
    - `(` 让 `dep++`
    - `)` 让 `dep--`
    - 如果 `dep` 减到小于0，说明右括号多了，必须“补左括号”
    - 累加 `needLeft`
    - 结束后如果 `dep>0`，说明最后多了左括号，记作 `needRight`

---

### 【2】DP数组声明 + 初始化

- 定义 `dp[i][j]` 表示：
    - 处理到第 `i` 个原串字符
    - 未配对左括号数是 `j` 时的方案数

**注意**：
- 因为你可以最多插入 `needLeft + n` 个左括号，所以 `j` 的范围是 `0~n+needLeft`（不需要开特别大）

**初始化**：

- `dp[0][0] = 1`
    - 表示空串、括号平衡值为0，有一种空方案

---

### 【3】状态转移（核心）

每个位置 `i=0` 到 `n`，每个未配对左括号数量 `j=0` 到 `n+needLeft`

#### 在当前位置前面的空隙，你可以做：

1. 插一个左括号：
    - 让 `j` 从 `j` 变成 `j+1`
    - `dp[i][j+1] += dp[i][j]`

2. 插一个右括号（只在 `j>0` 时）：
    - 让 `j` 从 `j` 变成 `j-1`
    - `dp[i][j-1] += dp[i][j]`

---

#### 然后处理原串的字符（如果还有没处理的）：

3. 如果 `s[i+1] == '('`:
    - 相当于左括号直接进入序列
    - `j` 变成 `j+1`

4. 如果 `s[i+1] == ')'`:
    - 只有在 `j > 0` 时可以用来配对
    - `j` 变成 `j-1`

---

### 【4】转移边界

转移前始终要保证：

- \(j \ge 0\) （括号平衡永远非负）
- \(j\) 不超过 `n + needLeft`

---

### 【5】最终答案

**答案就是**：

- `dp[n][0]`

表示：

- 已经处理完原串 \( s[1..n] \)
- 补上了最少的括号
- 且括号全部合法闭合（未配对左括号数为0）

---

## ✅ 总结（成型版）

| 模块 | 功能 |
|------|------|
| 输入 & 预处理 | 算出 `needLeft` 和 `needRight` |
| DP 定义 | \( dp[i][j] \) 表示前 `i` 个字符、未配对左括号数为 `j` 时的方案数 |
| DP 初始化 | `dp[0][0] = 1` |
| DP 转移 | 插左、插右、处理原串的 `(` 和 `)` |
| 答案 | `dp[n][0]` |

---

### ✅ 为什么要这样建模？

因为题目要求：

1. 插入的括号数量必须最少
2. 任意前缀的左括号数量 ≥ 右括号数量
3. 任意时刻的括号平衡用 `j` 表示，转移就变成了简单的平衡流动

---

如果你跟到这里，
接下来我可以帮你：

- 用具体样例跑一遍 DP
- 或者直接给出最终的、完整且风格符合你要求的代码
*/